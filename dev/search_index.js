var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Annotating-Types","page":"Guide","title":"Annotating Types","text":"Every type that you want to generate a schema for needs an annotate method that returns an Annotation. The annotation carries a name, description, and per-field metadata.\n\nusing DescribedTypes\nusing JSON\n\nstruct Weather\n    location::String\n    temperature::Float64\n    unit::String\nend\n\nDescribedTypes.annotate(::Type{Weather}) = Annotation(\n    name=\"Weather\",\n    description=\"Current weather observation.\",\n    parameters=Dict(\n        :location    => Annotation(name=\"location\", description=\"City name\"),\n        :temperature => Annotation(name=\"temperature\", description=\"Temperature value\"),\n        :unit        => Annotation(name=\"unit\", description=\"Unit of measurement\", enum=[\"celsius\", \"fahrenheit\"]),\n    ),\n)\nnothing # hide\n\nIf you don't define annotate for a type, a default annotation is generated using the type name, with generic field descriptions.","category":"section"},{"location":"guide/#Generating-Schemas","page":"Guide","title":"Generating Schemas","text":"Use schema to produce a JSON Schema dictionary.\n\nPlain JSON Schema (STANDARD):\n\nd = schema(Weather)\nprint(JSON.json(d, 2))\n\nOpenAI response-format wrapper (OPENAI):\n\nd = schema(Weather, llm_adapter=OPENAI)\nprint(JSON.json(d, 2))\n\nOpenAI function/tool-calling wrapper (OPENAI_TOOLS):\n\nd = schema(Weather, llm_adapter=OPENAI_TOOLS)\nprint(JSON.json(d, 2))","category":"section"},{"location":"guide/#Optional-Fields","page":"Guide","title":"Optional Fields","text":"Fields typed as Union{Nothing, T} are treated as optional:\n\nIn STANDARD mode they are omitted from the \"required\" array.\nIn OPENAI / OPENAI_TOOLS modes all fields remain required (per OpenAI spec), but optional fields use [\"type\", \"null\"] to allow a null value.\n\nstruct Query\n    text::String\n    max_tokens::Union{Nothing, Int}\nend\n\nDescribedTypes.annotate(::Type{Query}) = Annotation(\n    name=\"Query\",\n    description=\"A search query.\",\n    parameters=Dict(\n        :text       => Annotation(name=\"text\", description=\"The query string\"),\n        :max_tokens => Annotation(name=\"max_tokens\", description=\"Optional token limit\"),\n    ),\n)\nnothing # hide\n\nStandard schema (optional fields omitted from required):\n\nprint(JSON.json(schema(Query), 2))\n\nOpenAI schema (optional fields use [\"type\", \"null\"]):\n\nprint(JSON.json(schema(Query, llm_adapter=OPENAI), 2))","category":"section"},{"location":"guide/#Enum-Fields","page":"Guide","title":"Enum Fields","text":"There are two ways to represent enums:","category":"section"},{"location":"guide/#1.-Julia-@enum-types","page":"Guide","title":"1. Julia @enum types","text":"Automatically serialised to their string representations:\n\n@enum Color red green blue\n\nstruct Palette\n    primary::Color\nend\n\nprint(JSON.json(schema(Palette), 2))\n\nYou can also annotate the enum field with a description — the enum values are still inferred from the Julia type, so you don't need to repeat them:\n\nDescribedTypes.annotate(::Type{Palette}) = Annotation(\n    name=\"Palette\",\n    description=\"A color palette.\",\n    parameters=Dict(\n        :primary => Annotation(name=\"primary\", description=\"The primary color\"),\n    ),\n)\n\nprint(JSON.json(schema(Palette, llm_adapter=OPENAI), 2))","category":"section"},{"location":"guide/#2.-String-fields-with-enum-annotations","page":"Guide","title":"2. String fields with enum annotations","text":"Constrain allowed values via the enum keyword in Annotation:\n\nstruct Shirt\n    color::String\nend\n\nDescribedTypes.annotate(::Type{Shirt}) = Annotation(\n    name=\"Shirt\",\n    description=\"A shirt.\",\n    parameters=Dict(\n        :color => Annotation(name=\"color\", description=\"Shirt color\", enum=[\"red\", \"green\", \"blue\"]),\n    ),\n)\n\nprint(JSON.json(schema(Shirt, llm_adapter=OPENAI), 2))\n\nnote: Note\nThe enum keyword in annotations only takes effect in OpenAI modes (OPENAI / OPENAI_TOOLS). In STANDARD mode it is ignored.\n\nYou can also use symbols in the annotation enum values:\n\nDescribedTypes.annotate(::Type{Shirt}) = Annotation(\n    name=\"Shirt\",\n    description=\"A shirt.\",\n    parameters=Dict(\n        :color => Annotation(name=\"color\", description=\"Shirt color\", enum=[:red, :green, :blue]),\n    ),\n)\n\nprint(JSON.json(schema(Shirt, llm_adapter=OPENAI), 2))\n\nDuplicate handling is configurable when generating schema:\n\n# default: :dedupe\nschema(Shirt, llm_adapter=OPENAI)\n\n# strict: error on duplicates after normalization\n# schema(Shirt, llm_adapter=OPENAI, enum_duplicate_policy=:error)","category":"section"},{"location":"guide/#Nested-Types","page":"Guide","title":"Nested Types","text":"Nested structs are expanded inline by default:\n\nstruct Address\n    street::String\n    city::String\nend\n\nstruct Person\n    name::String\n    address::Address\nend\n\nprint(JSON.json(schema(Person), 2))","category":"section"},{"location":"guide/#Schema-References","page":"Guide","title":"Schema References","text":"For deeply nested or repeated types, pass use_references=true to factor shared types into $defs and reference them via $ref:\n\nprint(JSON.json(schema(Person, use_references=true), 2))","category":"section"},{"location":"guide/#Custom-Dict-Type","page":"Guide","title":"Custom Dict Type","text":"By default schemas use JSON.Object (preserves insertion order). You can switch to Dict if order doesn't matter:\n\nd = schema(Person, dict_type=Dict)\ntypeof(d)","category":"section"},{"location":"guide/#Function-Method-Schemas","page":"Guide","title":"Function Method Schemas","text":"DescribedTypes can also extract function-method signatures and generate tool-ready JSON schemas.\n\n\"\"\"\nWeather lookup helper.\n\"\"\"\nfunction weather(city::String, days::Int=3; unit::String=\"celsius\", include_humidity::Bool=false)\n    return (; city, days, unit, include_humidity)\nend\n\nsig = extractsignature(weather)\nsig.name, length(sig.args)\n\nYou can customize method/argument metadata with MethodAnnotation and ArgAnnotation:\n\nDescribedTypes.annotate(::typeof(weather), ms::MethodSignature) = MethodAnnotation(\n    name=:weather_tool,\n    description=\"Weather lookup tool.\",\n    argsannot=Dict(\n        :city => ArgAnnotation(name=:city, description=\"City name\", required=true),\n        :days => ArgAnnotation(name=:days, description=\"Forecast horizon\", required=false),\n        :unit => ArgAnnotation(name=:unit, description=\"Temperature unit\", enum=[\"celsius\", \"fahrenheit\"], required=false),\n        :include_humidity => ArgAnnotation(name=:include_humidity, description=\"Include humidity signal\", required=false),\n    ),\n)\nnothing # hide\n\nGenerate an OpenAI tool schema:\n\nprint(JSON.json(schema(weather, llm_adapter=OPENAI_TOOLS), 2))","category":"section"},{"location":"guide/#JSON-Function-Calling","page":"Guide","title":"JSON → Function Calling","text":"Use callfunction to validate/coerce JSON-style arguments and invoke the Julia function:\n\nres1 = callfunction(weather, Dict(\"city\" => \"Paris\"))\nres2 = callfunction(weather, \"{\\\"city\\\":\\\"Berlin\\\",\\\"days\\\":1,\\\"unit\\\":\\\"fahrenheit\\\"}\")\n(res1, res2)\n\nOpenAI-style wrapped payloads are also accepted:\n\ncallfunction(weather, Dict(\"arguments\" => \"{\\\"city\\\":\\\"Rome\\\",\\\"unit\\\":\\\"celsius\\\"}\"))","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"","category":"section"},{"location":"api/#DescribedTypes.schema","page":"API Reference","title":"DescribedTypes.schema","text":"schema(\n    schema_type::Type;\n    use_references::Bool = false,\n    dict_type::Type{<:AbstractDict} = JSON.Object,\n    llm_adapter::LLMAdapter = STANDARD,\n    enum_duplicate_policy::Symbol = :dedupe\n)::AbstractDict{String, Any}\n\nGenerate a JSON Schema dictionary from a Julia type.\n\nWhen llm_adapter is OPENAI, the schema is wrapped for the OpenAI response-format structured-output API (\"schema\" key).\n\nWhen llm_adapter is OPENAI_TOOLS, the schema is wrapped for OpenAI function / tool calling (\"parameters\" key).\n\nBoth OpenAI modes enforce strict: true, additionalProperties: false, and require all fields (optional fields use [\"type\", \"null\"]).\n\nWhen use_references is true, nested struct types are factored out into $defs and referenced via $ref.\n\nenum_duplicate_policy controls how annotation enum duplicates are handled after conversion to strings:\n\n:dedupe (default) keeps the first instance and removes repeats.\n:error throws an ArgumentError on duplicates.\n\nExamples\n\nstruct Person\n    name::String\n    age::Int\nend\n\nDescribedTypes.annotate(::Type{Person}) = DescribedTypes.Annotation(\n    name=\"Person\",\n    description=\"A person.\",\n    parameters=Dict(\n        :name => DescribedTypes.Annotation(name=\"name\", description=\"The person's name\"),\n        :age  => DescribedTypes.Annotation(name=\"age\", description=\"The person's age\")\n    )\n)\n\n# Plain JSON Schema\nschema(Person)\n\n# OpenAI response-format (uses \"schema\" wrapper key)\nschema(Person, llm_adapter=OPENAI)\n\n# OpenAI tool/function calling (uses \"parameters\" wrapper key)\nschema(Person, llm_adapter=OPENAI_TOOLS)\n\n\n\n\n\nschema(\n    fn::Function;\n    selector::Union{Int,Method,Function}=1,\n    method_annotation::Union{Nothing,MethodAnnotation}=nothing,\n    use_references::Bool=false,\n    dict_type::Type{<:AbstractDict}=JSON.Object,\n    llm_adapter::LLMAdapter=STANDARD,\n    enum_duplicate_policy::Symbol=:dedupe\n)::AbstractDict{String,Any}\n\nGenerate a JSON Schema dictionary from a Julia function method.\n\nselector chooses the function method (index, Method, or selector function).\nmethod_annotation allows explicit naming/description/per-arg metadata.\nllm_adapter=OPENAI_TOOLS emits a tool/function-calling wrapper.\nllm_adapter=OPENAI emits a structured-output wrapper.\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.Annotation","page":"API Reference","title":"DescribedTypes.Annotation","text":"Annotation(; name, description=\"\", markdown=\"\", enum=nothing, parameters=nothing)\n\nMetadata attached to a Julia type (or one of its fields) for JSON Schema generation.\n\nFields\n\nname::String — display name used in the schema\ndescription::String — human-readable description\nmarkdown::String — optional Markdown documentation\nenum::Union{Nothing,Vector{Union{String,Symbol}}} — allowable enum values (if any)\nparameters::Union{Nothing,Dict{Symbol,Annotation}} — per-field annotations\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.annotate","page":"API Reference","title":"DescribedTypes.annotate","text":"annotate(::Type{T}) -> Annotation\n\nReturn the Annotation for type T.\n\nOverride this method to attach descriptions and field metadata to your types:\n\nDescribedTypes.annotate(::Type{MyType}) = DescribedTypes.Annotation(\n    name = \"MyType\",\n    description = \"A short description.\",\n    parameters = Dict(\n        :field1 => DescribedTypes.Annotation(name=\"field1\", description=\"...\"),\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.LLMAdapter","page":"API Reference","title":"DescribedTypes.LLMAdapter","text":"LLMAdapter\n\nEnum selecting the LLM-provider schema format.\n\nSTANDARD     — plain JSON Schema\nOPENAI       — wrapped for OpenAI structured-output response format (\"schema\" key)\nOPENAI_TOOLS — wrapped for OpenAI function/tool calling (\"parameters\" key)\nGEMINI       — (placeholder) Google Gemini format\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.ArgAnnotation","page":"API Reference","title":"DescribedTypes.ArgAnnotation","text":"ArgAnnotation(; name, description=nothing, enum=nothing, required=true, llmexclude=false, userprovided=false)\n\nAnnotation metadata for one function argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.MethodAnnotation","page":"API Reference","title":"DescribedTypes.MethodAnnotation","text":"MethodAnnotation(; name, description=nothing, argsannot=Dict())\n\nAnnotation metadata for a function method.\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.MethodSignature","page":"API Reference","title":"DescribedTypes.MethodSignature","text":"MethodSignature\n\nExtracted signature model for one Julia function method.\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.PositionalArg","page":"API Reference","title":"DescribedTypes.PositionalArg","text":"PositionalArg\n\nInternal representation of an extracted positional function argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.KeywordArg","page":"API Reference","title":"DescribedTypes.KeywordArg","text":"KeywordArg\n\nInternal representation of an extracted keyword function argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.extractsignature","page":"API Reference","title":"DescribedTypes.extractsignature","text":"extractsignature(fn::Function, selector::Union{Int,Method,Function}=1) -> MethodSignature\n\nExtract a function-method signature into a schema-friendly representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.annotate!","page":"API Reference","title":"DescribedTypes.annotate!","text":"annotate!(ms::MethodSignature, ma::MethodAnnotation)\n\nApply method/argument annotations to an extracted method signature.\n\nFor safety, all arguments in ms must be present in ma.argsannot.\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.callfunction","page":"API Reference","title":"DescribedTypes.callfunction","text":"callfunction(\n    fn::Function,\n    arguments::Union{AbstractString,AbstractDict};\n    selector::Union{Int,Method,Function}=1,\n    method_annotation::Union{Nothing,MethodAnnotation}=nothing,\n)\n\nCall a Julia function from JSON-like arguments using extracted method metadata.\n\narguments can be a JSON string or dictionary-like object.\nSupports OpenAI-style { \"arguments\": \"{...}\" } and { \"arguments\": {...} }.\nValidates required/extra keys, coerces JSON values into Julia argument types, and invokes fn with positional and keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes._is_openai_mode","page":"API Reference","title":"DescribedTypes._is_openai_mode","text":"_is_openai_mode(adapter::LLMAdapter) -> Bool\n\nReturn true for any OpenAI-flavoured adapter (OPENAI or OPENAI_TOOLS). Used internally so that schema-generation rules shared by both modes are written once.\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes._normalize_enum_values","page":"API Reference","title":"DescribedTypes._normalize_enum_values","text":"Normalize annotation enum values for JSON output.\n\nConverts symbols/strings to strings. Duplicate handling is controlled by enum_duplicate_policy:\n\n:dedupe keeps first-seen order and removes repeats.\n:error throws ArgumentError when a duplicate is found.\n\n\n\n\n\n","category":"function"},{"location":"llm/#LLM-Optimized-Reference","page":"LLM Reference","title":"LLM-Optimized Reference","text":"Compressed single-page reference for LLM code-generation tools. Contains all public signatures, types, and usage patterns.","category":"section"},{"location":"llm/#Package","page":"LLM Reference","title":"Package","text":"using DescribedTypes\n# Exports: schema, Annotation, annotate, LLMAdapter, STANDARD, OPENAI, OPENAI_TOOLS, GEMINI,\n#          ArgAnnotation, MethodAnnotation, MethodSignature, PositionalArg, KeywordArg,\n#          extractsignature, annotate!, callfunction","category":"section"},{"location":"llm/#Types","page":"LLM Reference","title":"Types","text":"","category":"section"},{"location":"llm/#LLMAdapter","page":"LLM Reference","title":"LLMAdapter","text":"@enum LLMAdapter STANDARD OPENAI OPENAI_TOOLS GEMINI\n\nSelects the LLM-provider schema format:\n\nSTANDARD — plain JSON Schema (no wrapping).\nOPENAI — OpenAI structured-output response format; wraps schema under \"schema\" key, sets strict: true, additionalProperties: false, all fields required (optional → [\"type\", \"null\"]).\nOPENAI_TOOLS — OpenAI function/tool calling; wraps schema under \"parameters\" key with \"type\": \"function\", same strict rules as OPENAI.\nGEMINI — placeholder for Google Gemini format.","category":"section"},{"location":"llm/#Annotation","page":"LLM Reference","title":"Annotation","text":"Base.@kwdef struct Annotation\n    name::String\n    description::String = \"\"\n    markdown::String = \"\"\n    enum::Union{Nothing, Vector{Union{String,Symbol}}} = nothing\n    parameters::Union{Nothing, Dict{Symbol, Annotation}} = nothing\nend\n\nAnnotation(name::String)  # convenience; auto-generates description\n\nMetadata for a Julia type or field used during JSON Schema generation.\n\nname — display name in schema.\ndescription — human-readable description.\nmarkdown — optional Markdown docs.\nenum — constrained values (String and/or Symbol) for schema enums.\nparameters — per-field Annotation keyed by field name (Symbol).","category":"section"},{"location":"llm/#Function-annotation-types","page":"LLM Reference","title":"Function-annotation types","text":"struct ArgAnnotation\n    name::Symbol\n    description::Union{String,Nothing}\n    enum::Union{Vector,Nothing}\n    required::Bool\n    llmexclude::Bool\n    userprovided::Bool\nend\n\nBase.@kwdef struct MethodAnnotation\n    name::Symbol\n    description::Union{String,Nothing} = nothing\n    argsannot::Dict{Symbol,ArgAnnotation} = Dict{Symbol,ArgAnnotation}()\nend\n\nBase.@kwdef mutable struct MethodSignature\n    name::Symbol\n    description::Union{String,Nothing} = nothing\n    args::Vector{FunArg}\nend\n\nUse these to annotate extracted function methods before schema generation.","category":"section"},{"location":"llm/#Functions","page":"LLM Reference","title":"Functions","text":"","category":"section"},{"location":"llm/#annotate","page":"LLM Reference","title":"annotate","text":"annotate(::Type{T}) -> Annotation\nannotate(::Function, ::MethodSignature) -> MethodAnnotation\n\nOverride per type to attach metadata:\n\nDescribedTypes.annotate(::Type{MyStruct}) = Annotation(\n    name = \"MyStruct\",\n    description = \"Short description.\",\n    parameters = Dict(\n        :field1 => Annotation(name=\"field1\", description=\"Field 1 description\"),\n        :field2 => Annotation(name=\"field2\", description=\"Field 2 description\", enum=[\"a\", \"b\"]),\n    ),\n)\n\nDefault fallback uses string(T) as name with generic field descriptions. For functions, default fallback emits a MethodAnnotation with generic argument descriptions and inferred required/default behavior.","category":"section"},{"location":"llm/#schema","page":"LLM Reference","title":"schema","text":"schema(\n    schema_type::Type;\n    use_references::Bool = false,\n    dict_type::Type{<:AbstractDict} = JSON.Object,\n    llm_adapter::LLMAdapter = STANDARD,\n    enum_duplicate_policy::Symbol = :dedupe\n) -> AbstractDict{String, Any}\n\nschema(\n    fn::Function;\n    selector::Union{Int,Method,Function}=1,\n    method_annotation::Union{Nothing,MethodAnnotation}=nothing,\n    use_references::Bool=false,\n    dict_type::Type{<:AbstractDict}=JSON.Object,\n    llm_adapter::LLMAdapter=STANDARD,\n    enum_duplicate_policy::Symbol=:dedupe\n) -> AbstractDict{String, Any}\n\nGenerates a JSON Schema dictionary from a Julia type or a Julia function method.\n\nKeyword arguments:\n\nuse_references — when true, nested struct types are factored into $defs and referenced via $ref.\ndict_type — dictionary type for the output (default JSON.Object for ordered keys).\nllm_adapter — schema format selector (see LLMAdapter).\nenum_duplicate_policy — enum duplicate handling after string normalization:\n:dedupe (default): keep first-seen value, remove duplicates.\n:error: throw ArgumentError on duplicates.\n\nReturn shape by adapter:\n\nllm_adapter Top-level keys\nSTANDARD type, properties, required [, $defs]\nOPENAI name, description, strict, schema → {schema object}\nOPENAI_TOOLS type=\"function\", name, description, strict, parameters → {schema object}","category":"section"},{"location":"llm/#extractsignature","page":"LLM Reference","title":"extractsignature","text":"extractsignature(fn::Function, selector::Union{Int,Method,Function}=1) -> MethodSignature\n\nExtract one Julia function method into a schema-friendly signature model.","category":"section"},{"location":"llm/#annotate!","page":"LLM Reference","title":"annotate!","text":"annotate!(ms::MethodSignature, ma::MethodAnnotation)\n\nApply a MethodAnnotation to an extracted signature.","category":"section"},{"location":"llm/#callfunction","page":"LLM Reference","title":"callfunction","text":"callfunction(\n    fn::Function,\n    arguments::Union{AbstractString,AbstractDict};\n    selector::Union{Int,Method,Function}=1,\n    method_annotation::Union{Nothing,MethodAnnotation}=nothing,\n)\n\nValidate/coerce JSON-style arguments and call the Julia function method.","category":"section"},{"location":"llm/#Patterns","page":"LLM Reference","title":"Patterns","text":"","category":"section"},{"location":"llm/#Define-a-type-and-annotate-it","page":"LLM Reference","title":"Define a type and annotate it","text":"struct Weather\n    location::String\n    temperature::Float64\n    unit::String\nend\n\nDescribedTypes.annotate(::Type{Weather}) = Annotation(\n    name = \"Weather\",\n    description = \"Current weather observation.\",\n    parameters = Dict(\n        :location    => Annotation(name=\"location\", description=\"City name\"),\n        :temperature => Annotation(name=\"temperature\", description=\"Temperature value\"),\n        :unit        => Annotation(name=\"unit\", description=\"Unit of measurement\",\n                                   enum=[\"celsius\", \"fahrenheit\"]),\n    ),\n)","category":"section"},{"location":"llm/#Generate-schemas","page":"LLM Reference","title":"Generate schemas","text":"using JSON\n\n# Plain JSON Schema\nschema(Weather)\n\n# OpenAI structured output (response_format)\nschema(Weather, llm_adapter=OPENAI)\n\n# OpenAI tool/function calling\nschema(Weather, llm_adapter=OPENAI_TOOLS)\n\n# With $defs for nested types\nschema(Weather, use_references=true)","category":"section"},{"location":"llm/#Function-tool-schema-and-invocation","page":"LLM Reference","title":"Function tool schema and invocation","text":"function weather(city::String, days::Int=3; unit::String=\"celsius\")\n    return (; city, days, unit)\nend\n\nDescribedTypes.annotate(::typeof(weather), ms::MethodSignature) = MethodAnnotation(\n    name=:weather_tool,\n    description=\"Weather lookup tool.\",\n    argsannot=Dict(\n        :city => ArgAnnotation(name=:city, description=\"City name\", required=true),\n        :days => ArgAnnotation(name=:days, description=\"Forecast horizon\", required=false),\n        :unit => ArgAnnotation(name=:unit, description=\"Temperature unit\", enum=[\"celsius\", \"fahrenheit\"], required=false),\n    ),\n)\n\ntool_schema = schema(weather, llm_adapter=OPENAI_TOOLS)\nresult = callfunction(weather, Dict(\"city\" => \"Paris\", \"unit\" => \"fahrenheit\"))","category":"section"},{"location":"llm/#Optional-fields","page":"LLM Reference","title":"Optional fields","text":"Use Union{Nothing, T}. In STANDARD mode the field is not in required. In OPENAI/OPENAI_TOOLS mode the field stays required but its type becomes [\"type\", \"null\"].\n\nstruct Query\n    text::String\n    max_results::Union{Nothing, Int}\nend","category":"section"},{"location":"llm/#Nested-structs","page":"LLM Reference","title":"Nested structs","text":"struct Address\n    street::String\n    city::String\nend\n\nstruct Person\n    name::String\n    address::Address\nend\n\nNested structs are inlined by default. Pass use_references=true to factor them into $defs.","category":"section"},{"location":"llm/#Enums","page":"LLM Reference","title":"Enums","text":"Julia @enum types map to \"type\": \"string\" with \"enum\" values automatically. Field-level enums can also be set via the enum kwarg in Annotation.","category":"section"},{"location":"llm/#Serializing-to-JSON-string","page":"LLM Reference","title":"Serializing to JSON string","text":"import JSON\nJSON.json(schema(MyType), 2)        # pretty-printed\nJSON.json(schema(MyType, llm_adapter=OPENAI))  # compact","category":"section"},{"location":"llm/#Supported-Julia-type-mappings","page":"LLM Reference","title":"Supported Julia type mappings","text":"Julia type JSON Schema type\nString / AbstractString string\nBool boolean\n<:Integer integer\n<:Real number\nNothing / Missing null\n<:AbstractArray array\n<:Enum string + enum\nAny other struct object","category":"section"},{"location":"#DescribedTypes.jl","page":"Home","title":"DescribedTypes.jl","text":"Annotate Julia types/functions and generate JSON Schemas for LLM provider APIs.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"DescribedTypes.jl lets you attach human-readable descriptions to Julia struct types and Julia function methods, then automatically produces JSON Schema dictionaries compatible with LLM structured-output APIs.\n\nFor functions, the package also supports argument execution from JSON payloads: function -> schema and JSON -> typed function call.\n\nSupported adapters:\n\nAdapter Use case Wrapper key\nSTANDARD Plain JSON Schema (no wrapping) —\nOPENAI Structured output via response_format \"schema\"\nOPENAI_TOOLS Function / tool calling \"parameters\"\nGEMINI Google Gemini (placeholder) —","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"DescribedTypes\")\n\nOr in the Pkg REPL:\n\npkg> add DescribedTypes","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using DescribedTypes\nusing JSON\n\nstruct Person\n    name::String\n    age::Int\nend\n\nDescribedTypes.annotate(::Type{Person}) = Annotation(\n    name=\"Person\",\n    description=\"A person.\",\n    parameters=Dict(\n        :name => Annotation(name=\"name\", description=\"The person's name\", enum=[\"Alice\", \"Bob\"]),\n        :age  => Annotation(name=\"age\", description=\"The person's age\"),\n    ),\n)\n\n# OpenAI structured-output format\nschema_dict = schema(Person, llm_adapter=OPENAI)\nprint(JSON.json(schema_dict, 2))\n\nSee the Guide for more detailed usage and examples.","category":"section"}]
}
