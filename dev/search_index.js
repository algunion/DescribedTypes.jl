var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Annotating-Types","page":"Guide","title":"Annotating Types","text":"Every type that you want to generate a schema for needs an annotate method that returns an Annotation. The annotation carries a name, description, and per-field metadata.\n\nusing DescribedTypes\nusing JSON\n\nstruct Weather\n    location::String\n    temperature::Float64\n    unit::String\nend\n\nDescribedTypes.annotate(::Type{Weather}) = Annotation(\n    name=\"Weather\",\n    description=\"Current weather observation.\",\n    parameters=Dict(\n        :location    => Annotation(name=\"location\", description=\"City name\"),\n        :temperature => Annotation(name=\"temperature\", description=\"Temperature value\"),\n        :unit        => Annotation(name=\"unit\", description=\"Unit of measurement\", enum=[\"celsius\", \"fahrenheit\"]),\n    ),\n)\nnothing # hide\n\nIf you don't define annotate for a type, a default annotation is generated using the type name, with generic field descriptions.","category":"section"},{"location":"guide/#Generating-Schemas","page":"Guide","title":"Generating Schemas","text":"Use schema to produce a JSON Schema dictionary.\n\nPlain JSON Schema (STANDARD):\n\nd = schema(Weather)\nprint(JSON.json(d, 2))\n\nOpenAI response-format wrapper (OPENAI):\n\nd = schema(Weather, llm_adapter=OPENAI)\nprint(JSON.json(d, 2))\n\nOpenAI function/tool-calling wrapper (OPENAI_TOOLS):\n\nd = schema(Weather, llm_adapter=OPENAI_TOOLS)\nprint(JSON.json(d, 2))","category":"section"},{"location":"guide/#Optional-Fields","page":"Guide","title":"Optional Fields","text":"Fields typed as Union{Nothing, T} are treated as optional:\n\nIn STANDARD mode they are omitted from the \"required\" array.\nIn OPENAI / OPENAI_TOOLS modes all fields remain required (per OpenAI spec), but optional fields use [\"type\", \"null\"] to allow a null value.\n\nstruct Query\n    text::String\n    max_tokens::Union{Nothing, Int}\nend\n\nDescribedTypes.annotate(::Type{Query}) = Annotation(\n    name=\"Query\",\n    description=\"A search query.\",\n    parameters=Dict(\n        :text       => Annotation(name=\"text\", description=\"The query string\"),\n        :max_tokens => Annotation(name=\"max_tokens\", description=\"Optional token limit\"),\n    ),\n)\nnothing # hide\n\nStandard schema (optional fields omitted from required):\n\nprint(JSON.json(schema(Query), 2))\n\nOpenAI schema (optional fields use [\"type\", \"null\"]):\n\nprint(JSON.json(schema(Query, llm_adapter=OPENAI), 2))","category":"section"},{"location":"guide/#Enum-Fields","page":"Guide","title":"Enum Fields","text":"There are two ways to represent enums:","category":"section"},{"location":"guide/#1.-Julia-@enum-types","page":"Guide","title":"1. Julia @enum types","text":"Automatically serialised to their string representations:\n\n@enum Color red green blue\n\nstruct Palette\n    primary::Color\nend\n\nprint(JSON.json(schema(Palette), 2))","category":"section"},{"location":"guide/#2.-String-fields-with-enum-annotations","page":"Guide","title":"2. String fields with enum annotations","text":"Constrain allowed values via the enum keyword in Annotation:\n\nstruct Shirt\n    color::String\nend\n\nDescribedTypes.annotate(::Type{Shirt}) = Annotation(\n    name=\"Shirt\",\n    description=\"A shirt.\",\n    parameters=Dict(\n        :color => Annotation(name=\"color\", description=\"Shirt color\", enum=[\"red\", \"green\", \"blue\"]),\n    ),\n)\n\nprint(JSON.json(schema(Shirt, llm_adapter=OPENAI), 2))\n\nnote: Note\nThe enum keyword in annotations only takes effect in OpenAI modes (OPENAI / OPENAI_TOOLS). In STANDARD mode it is ignored.","category":"section"},{"location":"guide/#Nested-Types","page":"Guide","title":"Nested Types","text":"Nested structs are expanded inline by default:\n\nstruct Address\n    street::String\n    city::String\nend\n\nstruct Person\n    name::String\n    address::Address\nend\n\nprint(JSON.json(schema(Person), 2))","category":"section"},{"location":"guide/#Schema-References","page":"Guide","title":"Schema References","text":"For deeply nested or repeated types, pass use_references=true to factor shared types into $defs and reference them via $ref:\n\nprint(JSON.json(schema(Person, use_references=true), 2))","category":"section"},{"location":"guide/#Custom-Dict-Type","page":"Guide","title":"Custom Dict Type","text":"By default schemas use JSON.Object (preserves insertion order). You can switch to Dict if order doesn't matter:\n\nd = schema(Person, dict_type=Dict)\ntypeof(d)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"","category":"section"},{"location":"api/#DescribedTypes.schema","page":"API Reference","title":"DescribedTypes.schema","text":"schema(\n    schema_type::Type;\n    use_references::Bool = false,\n    dict_type::Type{<:AbstractDict} = JSON.Object,\n    llm_adapter::LLMAdapter = STANDARD\n)::AbstractDict{String, Any}\n\nGenerate a JSON Schema dictionary from a Julia type.\n\nWhen llm_adapter is OPENAI, the schema is wrapped for the OpenAI response-format structured-output API (\"schema\" key).\n\nWhen llm_adapter is OPENAI_TOOLS, the schema is wrapped for OpenAI function / tool calling (\"parameters\" key).\n\nBoth OpenAI modes enforce strict: true, additionalProperties: false, and require all fields (optional fields use [\"type\", \"null\"]).\n\nWhen use_references is true, nested struct types are factored out into $defs and referenced via $ref.\n\nExamples\n\nstruct Person\n    name::String\n    age::Int\nend\n\nDescribedTypes.annotate(::Type{Person}) = DescribedTypes.Annotation(\n    name=\"Person\",\n    description=\"A person.\",\n    parameters=Dict(\n        :name => DescribedTypes.Annotation(name=\"name\", description=\"The person's name\"),\n        :age  => DescribedTypes.Annotation(name=\"age\", description=\"The person's age\")\n    )\n)\n\n# Plain JSON Schema\nschema(Person)\n\n# OpenAI response-format (uses \"schema\" wrapper key)\nschema(Person, llm_adapter=OPENAI)\n\n# OpenAI tool/function calling (uses \"parameters\" wrapper key)\nschema(Person, llm_adapter=OPENAI_TOOLS)\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.Annotation","page":"API Reference","title":"DescribedTypes.Annotation","text":"Annotation(; name, description=\"\", markdown=\"\", enum=nothing, parameters=nothing)\n\nMetadata attached to a Julia type (or one of its fields) for JSON Schema generation.\n\nFields\n\nname::String — display name used in the schema\ndescription::String — human-readable description\nmarkdown::String — optional Markdown documentation\nenum::Union{Nothing,Vector{String}} — allowable enum values (if any)\nparameters::Union{Nothing,Dict{Symbol,Annotation}} — per-field annotations\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes.annotate","page":"API Reference","title":"DescribedTypes.annotate","text":"annotate(::Type{T}) -> Annotation\n\nReturn the Annotation for type T.\n\nOverride this method to attach descriptions and field metadata to your types:\n\nDescribedTypes.annotate(::Type{MyType}) = DescribedTypes.Annotation(\n    name = \"MyType\",\n    description = \"A short description.\",\n    parameters = Dict(\n        :field1 => DescribedTypes.Annotation(name=\"field1\", description=\"...\"),\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#DescribedTypes.LLMAdapter","page":"API Reference","title":"DescribedTypes.LLMAdapter","text":"LLMAdapter\n\nEnum selecting the LLM-provider schema format.\n\nSTANDARD     — plain JSON Schema\nOPENAI       — wrapped for OpenAI structured-output response format (\"schema\" key)\nOPENAI_TOOLS — wrapped for OpenAI function/tool calling (\"parameters\" key)\nGEMINI       — (placeholder) Google Gemini format\n\n\n\n\n\n","category":"type"},{"location":"api/#DescribedTypes._is_openai_mode","page":"API Reference","title":"DescribedTypes._is_openai_mode","text":"_is_openai_mode(adapter::LLMAdapter) -> Bool\n\nReturn true for any OpenAI-flavoured adapter (OPENAI or OPENAI_TOOLS). Used internally so that schema-generation rules shared by both modes are written once.\n\n\n\n\n\n","category":"function"},{"location":"#DescribedTypes.jl","page":"Home","title":"DescribedTypes.jl","text":"Annotate Julia types with descriptions and generate JSON Schemas for LLM provider APIs.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"DescribedTypes.jl lets you attach human-readable descriptions to Julia struct types and their fields, then automatically produces JSON Schema dictionaries compatible with LLM structured-output APIs.\n\nSupported adapters:\n\nAdapter Use case Wrapper key\nSTANDARD Plain JSON Schema (no wrapping) —\nOPENAI Structured output via response_format \"schema\"\nOPENAI_TOOLS Function / tool calling \"parameters\"\nGEMINI Google Gemini (placeholder) —","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"DescribedTypes\")\n\nOr in the Pkg REPL:\n\npkg> add DescribedTypes","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using DescribedTypes\nusing JSON\n\nstruct Person\n    name::String\n    age::Int\nend\n\nDescribedTypes.annotate(::Type{Person}) = Annotation(\n    name=\"Person\",\n    description=\"A person.\",\n    parameters=Dict(\n        :name => Annotation(name=\"name\", description=\"The person's name\", enum=[\"Alice\", \"Bob\"]),\n        :age  => Annotation(name=\"age\", description=\"The person's age\"),\n    ),\n)\n\n# OpenAI structured-output format\nschema_dict = schema(Person, llm_adapter=OPENAI)\nprint(JSON.json(schema_dict, 2))\n\nSee the Guide for more detailed usage and examples.","category":"section"}]
}
